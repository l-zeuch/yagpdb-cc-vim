# Test case file for syntax matching

# Copyright (C) 2021    Lucas Ritzdorf, Luca Zeuch

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Language: YAGPDB Custom Commands
# Maintainer: Luca Zeuch <l-zeuch@email.de>,
#   LRitzdorf <42657792+LRitzdorf@users.noreply.github.com>


# Available syntax functions are:
#   SyntaxAt(): current cursor position
#   SyntaxAt(col): current cursor line, at given column
#   SyntaxAt(lnum, col): line and column
#   SyntaxOf(pattern[, nth=1]): return a string with the name of the syntax
#     group at the first character of the nth match of the given pattern. Return
#     '' if there was no match.
# Our syntax groups are named based on the built-in group names, prefixed with
# "yagpdbcc" - for example, "yagpdbccFunction".

Before:
  source ../syntax/yagpdbcc.vim
  source ../syntax/yagpdbcc/*.vim

After:
  Restore

Given (code with comments):
  {{-   /*Initial $comment.test.asdf*/}}
  Normal text here
  {{/* How about {{ braces in }} comments? Looks good! */}}
  {{/* TODO: Here's a thing! */}}
  TODO: Testing, this shouldn't highlight
  {{/* FIXME: Just kidding! We're all good */}}
  $asdf.abcd{{/*
      Multiple lines
      Here's a neat comment!
      More lines
  */ -}}
  {{ print "This isn't valid syntax in the first place" /* asdf */}}

Execute (syntax check):
# Opening brace
  AssertEqual 'yagComment', SyntaxAt(1, 1), "Match comment region opening brace"

# Closing brace and following line
  AssertEqual 'yagComment', SyntaxAt(1, 37), "Comment region last match"
  AssertEqual '', SyntaxAt(2, 1), "Comment region actually ends"

# Ensure text inside and after the extra braces is still a comment
  AssertEqual 'yagComment', SyntaxAt(3, 19), "Comment region continues inside"
  AssertEqual 'yagComment', SyntaxAt(3, 32), "Comment region continues inside"

# TODOs and FIXMEs, but only inside comments
  AssertEqual 'yagTodo', SyntaxAt(4, 6), "Match TODO inside comments"
  AssertEqual 'yagComment', SyntaxAt(4, 12), "Don't expand TODO match too far"
  AssertEqual '', SyntaxAt(5, 1), "Don't match TODO outside of comment"
  AssertEqual 'yagTodo', SyntaxAt(6, 6), "Match FIXME inside comment"
  AssertEqual 'yagComment', SyntaxAt(6, 13), "Don't expand FIXME match too far"

# a plain text area
  AssertEqual '', SyntaxAt(7, 1), "Match plain text area with no syntax"

# Multiline comments
  AssertEqual 'yagComment', SyntaxAt(7, 13), "Match multiline comment 1/5"
  AssertEqual 'yagComment', SyntaxAt(8, 1), "Match multiline comment 2/5"
  AssertEqual 'yagComment', SyntaxAt(10, 1), "Match multiline comment 3/5"
  AssertEqual 'yagComment', SyntaxAt(11, 2), "Match multiline comment 4/5"
  AssertEqual 'yagComment', SyntaxAt(11, 5), "Match multiline comment 5/5"

# Don't match the invalid embedded comment syntax
  AssertEqual 'yagExpr', SyntaxAt(12, 58), "Don't match invalid embedded comment"

Given (normal code sample):
  {{ $args := parseArgs 0 "Please run this command with a user (mention or ID), or without any arguments (in which case it will run on you)."
      (carg "userid" "User to analyze") }}
  {{ $member := 0 }} {{ $user := 0 }} range 5 "asdf" {{/* Comments, woo! */}}
  {{ if $args.Get 0 }}
      {{ $user = userArg ($args.Get 0) }}
      {{ $member = getMember $user.ID }}
  {{ else }}
      {{ $user = .User }}
      {{ $member = .Member }}
  {{ end }}
  {{ $single_const := 'h' }}
  {{ $escape_const := '\n' }}
  {{ $single_quote := '"' }}

Execute (syntax check):
# Validate syntax elements in the first and second lines
  AssertEqual 'yagIdentifier', SyntaxAt(1, 4), "Match identifier"
  AssertEqual 'yagOperator', SyntaxAt(1, 10), "Match operator"
  AssertEqual 'yagFunc', SyntaxAt(1, 13), "Match inbuilt function name"
  AssertEqual 'yagIntImg', SyntaxAt(1, 23), "Match number"
  AssertEqual 'yagString', SyntaxAt(1, 27), "Match string"
  AssertEqual 'yagFunc', SyntaxAt(2, 6), "Match inbuilt function name w/ line continuation inside braces"

# Validate the third line, with its non-standard format
  AssertEqual 'yagIdentifier', SyntaxAt(3, 4), "Match identifer inside braces"
  AssertEqual '', SyntaxAt(3, 19), "Don't match characters after closing brace"
  AssertEqual '', SyntaxAt(3, 37), "Don't match syntax keywords outside braces"
  AssertEqual '', SyntaxAt(3, 43), "Don't match numbers outside braces"
  AssertEqual '', SyntaxAt(3, 45), "Don't match strings outside braces"
  AssertEqual 'yagComment', SyntaxAt(3, 57), "Match comments inside braces"

# Strings
  AssertEqual 'yagString', SyntaxAt(2, 11), "Match string delimiter start w/ line continuation inside braces"
  AssertEqual 'yagString', SyntaxAt(2, 20), "Match string content w/ line continuation inside braces"
  AssertEqual '', SyntaxAt(2, 39), "Don't expand string match too far"

# Check the new syntax elements in the following lines (no need to re-check
# variable matching, for example - that's already been validated)
# ifs and elses are part of the conditional group
  AssertEqual 'yagCond', SyntaxAt(4, 4), "Match conditional keyword inside braces"

# The .Get method on line 5 isn't matched, so it's just part of a basic
# expression region
  AssertEqual 'yagFunc', SyntaxAt(5, 16), "Match inbuilt function name"
  AssertEqual 'yagExpr', SyntaxAt(5, 30), "Don't match methods"
  AssertEqual 'yagFunc', SyntaxAt(6, 18), "Match inbuilt function name"
  AssertEqual 'yagCond', SyntaxAt(7, 4), "Match conditional keyword"
  AssertEqual 'yagOperator', SyntaxAt(8, 14), "Match operator"

# Objects, like .User and .Member, are matched as types
  AssertEqual 'yagObject', SyntaxAt(8, 16), "Match level-1 object"
  AssertEqual 'yagObject', SyntaxAt(9, 18), "Match level-1 object"

# end is just a general keyword
  AssertEqual 'yagKeyword', SyntaxAt(10, 4), "Match `end` keyword"

# Single character constants
  AssertEqual 'yagChar', SyntaxAt(11, 21), "Match single character constant"
  AssertEqual 'yagChar', SyntaxAt(11, 22), "Match single character constant end delimiter"
  AssertEqual '', SyntaxAt(11, 26), "Don't expand character match too far"

# Escape character constant
  AssertEqual 'yagChar', SyntaxAt(12, 21), "Match first character of escape sequence in character constant"
  AssertEqual 'yagChar', SyntaxAt(12, 23), "Match character constant end delimiter"
  AssertEqual '', SyntaxAt(12, 27), "Don't expand character match too far"

# This will be fun, '"' is really weird.
  AssertEqual 'yagChar', SyntaxAt(13, 21), "Match \" inside character constants"
  AssertEqual 'yagChar', SyntaxAt(13, 22), "Match character string delimiter"
  AssertEqual '', SyntaxAt(13, 26), "Don't expand match too far"


Given (code with errors):
  {{ print "This is a common syntax mistake: " {{.User.Username}} }}
  {{ print "This variable is invalid: " $abc$def.RandomAttribute }}
  This {{"{{"}} is valid
  {{ $invalid_const := 'hello' }}
  {{ $funky_escape := '\n hmm' }}

Execute (syntax check):
# The classic beginner syntax mistake
  AssertEqual 'yagNestedBrace', SyntaxAt(1, 46), "Match error on nested braces"
  AssertEqual '', SyntaxAt(1, 66), "Don't expand error match too far"

# Invalid Variable naming
  AssertEqual 'yagError', SyntaxAt(2, 43), "Match error on invalid identifier"
  AssertEqual '', SyntaxAt(2, 65), "Don't expand error too far"

# Weird, but valid edge case
  AssertEqual 'yagString', SyntaxAt(3, 9), "Don't match \"{{\" as error"
  AssertEqual '', SyntaxAt(3, 22), "Don't expand string match too far"

# Invalid character constant
  AssertEqual 'yagCharError', SyntaxAt(4, 22), "Match error for multiple character constants"
  AssertEqual 'yagCharError', SyntaxAt(4, 23), "Match end delimiter as error as well"
  AssertEqual '', SyntaxAt(4, 31), "Don't expand error too far"

# Strange character constant edge case (just why)
  AssertEqual 'yagCharError', SyntaxAt(5, 21), "Match error on things like \'\n something\'"
  AssertEqual 'yagCharError', SyntaxAt(4, 27), "Match end delimiter as error as well"
  AssertEqual '', SyntaxAt(4, 31), "Don't expand error too far"

Given (a variety of syntax elements):
  Even with weird variables, {{ print "like " $.Name }}, and the empty variable!
  {{.Asdf.Append . }}
  {{ $5_asdf := $ }}
  {{- print "Hello\nWorld" . .Example. -}}
  {{ joinStr "\"" "hello" "there" }}
  {{ printf "My favorite number is %d" 0xA1 }}
  {{ print "This example is " true }}
  {{- printf `Long string with
  line breaks and
  formatting %d%%` 100 -}}
  {{ add 1 -5e6 | mult (3e7i add 5E2) | printf "%s %d" ($args.Get 0).Username }}
  {{.Message.Mentions.Asdf.Jkl}}
  {{ $created := div $user.ID 4194304 | add 1420070400000 | mult 1000000 | toDuration | (newDate 1970 1 1 0 0 0).Add }}

Execute (syntax check):
# TODO (just pass for now)
# Don't forget to check time functions and printf formatting
  AssertEqual 1, 1

Given (custom embed with lots of nested syntax elements):
  {{ $embed := cembed
      "title" (printf "User info: `%s`" $user.Username)
      "description" "See below for details on this user."
      "color" $color
      "fields" (cslice
          (sdict "name" "User ID" "value" (toString $user.ID) "inline" false)
          (sdict "name" "Server nickname" "value" $nick "inline" false)
          (sdict "name" "Server join info" "value" (printf "Joined on %s, %s ago" (formatTime $member.JoinedAt.Parse) (humanizeDurationHours (currentTime.Sub $member.JoinedAt.Parse))) "inline" false)
      )
      "thumbnail" (sdict "url" ($user.AvatarURL "256"))
      "footer" (sdict "text" (printf "Account created %s, %s ago" (formatTime $created) (humanizeDurationHours (currentTime.Sub $created))))
  }}
  {{ sendMessage nil $embed }}

Execute (syntax check):
# TODO (just pass for now)
  AssertEqual 1, 1

